/*
 * WHAM -- Routines for bootstrap Monte Carlo error analysis
 * $Revision: 147 $
 * $Author: alan $
 * $Date: 2003/10/06 13:36:51 $
 * 
 * This set of routines is involved with performing bootstrap Monte Carlo
 * error analysis.  This technique is commonly used to estimate the statistical 
 * uncertainty in an average quantity calculated from a time series.  In the 
 * usual implementation, a series of fake data sets are derived from the true
 * time series.  The average of the quantity in question is calculated for each 
 * fake data set, and the standard deviation of the average over the fake data 
 * sets is the statistical uncertainty.  Assuming the original data set has N 
 * points, the fake data sets are generated by picking points at random from
 * original data set N times, allowing points to be picked more than once.
 *
 * The implementation here is slightly trickier, because I don't want to store
 * the time series, which are much bigger than the resulting histograms. 
 * However, what makes the normal bootstrap method work is the fact that the 
 * probability distribution from the original data set is used to generate fake
 * data sets, and that precisely is what we have available in the histograms.
 * So, the procedure for performing a Monte Carlo bootstrap is as follows:
 *
 * 1. For each window, randomly sample from its raw histogram to generate a 
 *    fake histogram.  This is done by computing the cumulative distribution
 *    function, picking a bin at random, and figuring out which value of the 
 *    histogram is contained in that bin.
 * 2. Once I have a fake histogram for each window, the usual WHAM iterations 
 *    are performed.  To speed convergence, I will seed F values for each window
 *    to be the converged values with the original data, rather than zeros.
 * 3. Repeat 1 and 2 a number of times, accumulating the standard deviation
 *    in the resulting probabilities.
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "wham.h"

int get_rand_bin(double *cum, int num_bins, long *idum)
/*
 * Randomly generate a count in a histogram, from a distribution whose cumulant 
 * is cum.  
 *
 * This trick for generating random numbers from an arbitrary distribution is 
 * described Section 7.2 of Numerical Recipes, especially Figure 7.2.1.  They
 * expect you to get the cumulant (the integral of the function) analytically,
 * but in this case I compute the cumulant numerically from the stored 
 * histogram.  Clever, huh?
 */
{
int j;
double val;

/* randomly generate a value between 0 and 1, representing a value in the
 * cumulative probability distribution
 */
val = ran2(idum);

/*
 * Find the index of val in the cumulative distribution cum
 * The original version of locate assumed [1..num_bins], so we passed
 * cum-1.  However, I changed locate to assume [0..num_bins-1], so
 * we should be fine.
 */
locate(cum, num_bins, val, &j);
return j;
}


void mk_new_hist(double *cum, double *dist, int num_bins, int num_points, 
                 long *idum)
/*
 * Generate a new random normalized histogram with num_points points, such 
 * that it's generated from the same distribution that produced the cumulative
 * distribution cum
 *
 * cum and dist are presumed to have the same number of bins, num_bins
 */
{
int i,j;
//double incr = 1.0/(double)num_points;
double incr = 1.0;

// zero out new
for (i=0; i<num_bins; i++)
    {
    dist[i] = 0.0;
    } 
for (i=0; i<num_points; i++)
    {
    j = get_rand_bin(cum, num_bins, idum);
    dist[j] += incr;
    }
}    
